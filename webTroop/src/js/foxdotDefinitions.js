import CodeMirror from 'codemirror';

const definitions = {
    PRand: '(start, stop=None, **kwargs)\r\n Returns a random integer between start and stop. If start is a container-type it returns\na random item for that container. ', 
    PWhite: '(lo=0, hi=1, **kwargs)\r\n Returns random floating point values between lo and hi', 
    PxRand: '(start, stop=None, **kwargs)\r\nNone', 
    PwRand: '(values, weights, **kwargs)\r\nNone', 
    PChain: '(mapping, **kwargs)\r\n An example of a Markov Chain generator pattern. The mapping argument \r\nshould be a dictionary of keys whose values are a list/pattern of possible\r\ndestinations.  ', 
    PZ12: '(tokens=[1, 0], p=[1, 0.5])\r\n Implementation of the PZ12 algorithm for predetermined random numbers. Using\r\nan irrational value for p, however, results in a non-determined order of values. \r\nExperimental, only works with 2 values.', 
    PTree: '(n=0, f=<function PTree.<lambda>, choose=<function PTree.<lambda>, **kwargs)\r\n Takes a starting value and two functions as arguments.\nThe first function, f, must take one value and return a container-type of values \nand the second function, choose,must take a container-type and return a single value.\n In essence you are creating a tree based on the f(n) \nwhere n is the last value chosen by choose.', 
    PWalk: '(max=7, step=1, start=0, **kwargs)\r\nNone', 
    PDelta: '(deltas, start=0)\r\nNone', 
    PSquare: '(**kwargs)\r\n Returns the square of the index being accessed ', 
    PIndex: '(**kwargs)\r\n Returns the index being accessed ', 
    PFibMod: '(**kwargs)\r\n Returns the fibonacci sequence -- maybe a bad idea', 
    PShuf: '(seq)\r\n PShuf(seq) -> Returns a shuffled version of seq', 
    PAlt: '(pat1, pat2, *patN)\r\n Returns a Pattern generated by alternating the values in the given sequences ', 
    PStretch: '(seq, size)\r\n Returns <seq> as a Pattern and looped until its length is <size>\ne.g. PStretch([0,1,2], 5) returns P[0, 1, 2, 0, 1]', 
    PPairs: '(seq, func=<function <lambda>>)\r\n Laces a sequence with a second sequence obtained\nby performing a function on the original. By default this is\n`lambda n: 8 - n`. ', 
    PZip: '(pat1, pat2, *patN)\r\n Creates a Pattern that <zips> together multiple patterns. `PZip([0,1,2], [3,4])`\nwill create the Pattern `P[(0, 3), (1, 4), (2, 3), (0, 4), (1, 3), (2, 4)]` ', 
    PZip2: '(pat1, pat2, rule=<function <lambda>>)\r\n Like `PZip` but only uses two Patterns. Zips together values if they satisfy the rule. ', 
    PStutter: '(x, n=2)\r\n PStutter(seq, n) -> Creates a pattern such that each item in the array is repeated n times (n can be a pattern) ', 
    PSq: '(a=1, b=2, c=3)\r\n Returns a Pattern of square numbers in the range a to a+c ', 
    P10: '(n)\r\n Returns an n-length Pattern of a randomly generated series of 1 and 0', 
    PStep: '(n, value, default=0, offset=0)\r\n Returns a Pattern that every n-term is <value> otherwise <default> ', 
    PSum: '(n, total, **kwargs)\r\nReturns a Pattern of length n that sums to equal total\n\n    e.g. PSum(3,8) -> P[3, 3, 2]\nPSum(5,4) -> P[1, 0.75, 0.75, 0.75, 0.75]\n    ', 
    PRange: '(start, stop=None, step=1)\r\n Returns a Pattern equivalent to ``Pattern(range(start, stop, step))`` ', 
    PTri: '(start, stop=None, step=1)\r\n Returns a Pattern equivalent to ``Pattern(range(start, stop, step))`` with its reversed form appended.', 
    PSine: '(n=16)\r\n Returns values of one cycle of sine wave split into <n> parts ',
    PEuclid: '(n, k)\r\n Returns the Euclidean rhythm which spreads <n> pulses over <k> steps as evenly as possible.\ne.g. `PEuclid(3, 8)` will return `P[1, 0, 0, 1, 0, 0, 1, 0]` ', 
    PEuclid2: '(n, k, lo, hi)\r\n Same as PEuclid except it returns an array filled with \'lo\' value instead of 0\nand \'hi\' value instead of 1. Can be used to generate characters patterns used to\n play sample like play(PEuclid2(3,8,\'-\',\'X\')) will be equivalent to\n play(P[\'X\', \'-\', \'-\', \'X\', \'-\', \'-\', \'X\', \'-\'])\n that\'s like saying play(X--X--X-)\n', 
    PBern: '(size=16, ratio=0.5)\r\n Returns a pattern of 1s and 0s based on the ratio value (between 0 and 1).\nThis is called a Bernoulli sequence. ', 
    PBeat: '(string, start=0, dur=0.5)\r\n Returns a Pattern of durations based on an input string where\n non-whitespace or non-point denote a pulse e.g.\n        ::\n\n>>> PBeat(x xxx x)\nP[1, 0.5, 0.5, 1, 0.5]\n ', 
    PDur: '(n, k, start=0, dur=0.25)\r\n Returns the *actual* durations based on Euclidean rhythms (see PEuclid) where dur\n is the length of each step.\n        ::\n>>> PDur(3, 8)\nP[0.75, 0.75, 0.5]\n>>> PDur(5, 16)\nP[0.75, 0.75, 0.75, 0.75, 1]\n',
    PDelay: '(*args)\r\n', 
    PStrum: '(n=4)\r\n Returns a pattern of durations similar to how you might strum a guitar ', 
    PQuicken: '(dur=0.5, stepsize=3, steps=6)\r\n Returns a PGroup of delay amounts that gradually decrease ', 
    PRhythm: '(durations)\r\n Converts all tuples/PGroups into delays calculated using the PDur algorithm.\ne.g.\nPRhythm([1,(3,8)]) -> P[1,(2,0.75,1.5)]\n    *work in progress*\n', 
    PJoin: '(patterns)\r\n Joins a list of patterns together ', 
    linvar: '(values, dur=None, start=0, **kwargs)\r\n', 
    expvar: '(values, dur=None, start=0, **kwargs)\r\n', 
    sinvar: '(values, dur=None, start=0, **kwargs)\r\n', 
    Pvar: '(values, dur=None, **kwargs)\r\n A TimeVar that represents Patterns that change over time e.g.\n>>> a = Pvar([ [0,1,2,3], [4,5] ], 4)\n>>> print a # time is 0\nP[0, 1, 2, 3]\n>>> print a # time is 4\nP[4, 5]\n', 
    PBin: '(number=0)\r\n Returns a random binary pattern or convert number to bin pattern ', 
    PSaw: '(n=16, inverse=0)\r\n Returns values of one cycle of Saw wave split into <n> parts ', 
    PTime: '()\r\nGenerate a pattern from the local machine time', 
    PTimebin: '()\r\nGenerate a pattern of actual time converted to binary', 
    PFrac: '(a=0.63, b=0.0, size=16, mapl=0, maph=1)\r\n return a Pattern with fractional step, \nnot sure what it is but sounds cool try with:  \na = 0.63, b = 0.00\na = 0.66, b = 0.08\na = 0.42, b = 0.10\na = 0.60, b = 0.68\na = 0.62, b = 0.67\n', 
    PFr: '(mapl=0, maph=1, seedFr=1664, size=16)\r\n Simpliest version of PFrac ', lininf: '(start=0, finish=1, time=32)\r\n linvar from start to finish but stay at finish after time ', 
    expinf: '(start=0, finish=1, time=32)\r\n expvar from start to finish but stay at finish after time ', 
    linbpm: '(endBpm=170, durBpm=128)\r\n use with Clock.bpm = linbpm(220, 12) to change bpm from current bpm to target in x beats', 
    linmod: '(start, end, duration, default=0)\r\n linvar from start to end during duration at next mod(duration) and switch back to default', 
    PDrum: '(style=None, pat="", listen=False, khsor="", duree=0.5, spl=0, charPlayer="d")\r\n Generate a drum pattern style ', 
    PChords: '(chord=None, **kwargs)\r\n Chords generator ', 
    PGauss: '(mean=0, deviation=1, **kwargs)\r\n Returns random floating point values using Gaussian distribution ', 
    PLog: '(mean=0, deviation=1, **kwargs)\r\n Returns random floating point values using logarithmic distribution ', 
    PTrir: '(low=0, high=8, mode=None, **kwargs)\r\n Returns random floating or int point values using triangular distribution ', 
    PCoin: '(low=0, high=1, proba=0.5, **kwargs)\r\n Choose between 2 values with probability, eg : PCoin(0.25,2,0.2)', 
    PChar: '(case=2, alpha=2, **kwargs)\r\n Generate characters randomly, PChar(case, alpha)\ncase = 0 , only lowercase\ncase = 1 , only uppercase\ncase = 2 , lower case and uppercase\nalpha = 0, only alpha\nalpha = 1, only nonalpha\nalpha = 2, alpha + nonalpha', 
    PMarkov: '(init_value="", **kwargs)\r\n An example of a Markov Chain generator pattern. The mapping argument\nshould be a dictionary of keys whose values are a list/pattern of possible\ndestinations.  Mod to add probability', 
    PZero: '(size=2, offset=0)\r\n Generate a Pattern with "1" and size-1 "0" \neg: PZero(5) -> P[1,0,0,0,0] \nthe "1" position can be offset \n', 
    PBool: '(pat1=P[0], pat2=P[0], operator=0)\r\n Binary operation between 2 Pattern, you can select the operator:\n0 -> and\n1 -> or\n2 -> xor   ', 
    PRy: '(total=16, div=4, restProb=0)\r\n Generate a ryhtm pattern ',
    ascii_gen: '(text="", font="")\r\n Generate ASCII art from text ', 
    connect: '()\r\n Full reset and set bpm, root, sos & video player ', 
    attack: '(attackName, prntOut=0)\r\n Get the attack code ', 
    lost: '(attack=None)\r\n List of all attacks ', 
    print_synth: '(synth="")\r\n Show the name and the args of a synth ', 
    print_loops: '(loop="")\r\n print all available loops samples ', 
    print_sample: '(sample="")\r\n print description of samples or find the corresponding letter ', 
    print_fx: '(fx="")\r\n Show the name and the args of a fx ', 
    pshort: '(short="")\r\n helper to shortcut ', 
    PMorse: '(text, point=0.25, tiret=0.75)\r\n Convert a string to the value of point & tiret ', 
    unsolo: '()\r\n Unsolo all solo players', 
    soloRnd: '(time=8, soloPlayer=None)\r\n solo a random player at time modulo ', gtr: '(self, strings=1)\r\n set player to match guitar string', 
    chroma: '(self)\r\n Set player to chromatic scale ', porta: '(self, portDelay=0.5)\r\nNone', 
    morph: '(self, other, prob=50)\r\n morph randomly some attrinute between 2 players, prob = amount of probability (100: full target player)', 
    trim: '(self, length)\r\nTrim to length evey pattern of player', 
    genArp: '(nbrseq=4, lengthseq=8)\r\n Generate arpeggiato based on markov Chords progression ', 
    masterAll: '(args=0, value=1, *argsall)\r\n set temporary a master FX, reset with 0 ', 
    voice_count: '()\r\n random count recursively every 8 bars.\nvoicecount.start(lang=fr, voice=2, dur=8, amp=1.0, pitch=0.0)\nvoicecount.help() to show all available voices', 
    random_bpm_var: '()\r\nChange the clock randomly with random var', 
    random_bpm: '()\r\n Change Clock to a random number', 
    setseed: '(seed=None)\r\nNone', 
    unison: '(self, unison=2, detune=0.125, analog=0)\r\n Like spread(), but can specify number of voices(unison)\nSets pan to (-1,-0.5,..,0.5,1) and pshift to (-0.125,-0.0625,...,0.0625,0.125)\nIf unison is odd, an unchanged voice is added in the center\nEg : p1.unison(4, 0.5) => pshift=(-0.5,-0.25,0.25,0.5), pan=(-1.0,-0.5,0.5,1.0)\np1.unison(5, 0.8) => pshift=(-0.8,-0.4,0,0.4,0.8), pan=(-1.0,-0.5,0,0.5,1.0)\np1.unison(5,(0.3,2)) => pshift=(-2.0,-0.3,0,0.3,2.0), pan=(-1,-0.5,0,0.5,1)\n', 
    human: '(self, velocity=20, humanize=5, swing=0)\r\n Humanize the velocity, delay and add swing in % (less to more)', 
    fill: '(self, mute_player=0, on=1)\r\n add fill to a drum player\nyou can mute other players with .fill(Group(p1,d2,d3))\n0 = off\n1 = dur + amplify\n2 = dur  //  amplify =1\n3 = amplify // dur=1/2\n', 
    brk: '(self, multi=1, code="")\r\n turn loop into break beat (only with splitter player ', 
    darker: '()\r\n Change Scale to a darkest one ', 
    lighter: '()\r\n Change Scale to a lightest one ', 
    switch: '(self, other, key, bypass=1)\r\n Switch the attr of a player\neg: b1 >> dbass(P[0:4], amp=1)\nb2 >> blip(-2, amp=1).switch(b1, degree)\'', 
    clone: '(self, player)\r\n Clone a player, eg: a2 >> saw().clone(a1)', 
    drop: '(playTime=14, dropTime=2, nbloop=1)\r\n Drop the amplify to 0 for random players.\nex : drop(6,2,4) => amplify=0 for random playing players at the 2 last beats of 8, 4 times\n', 
    drop_bpm: '(duree=32, nbr=0, end=4)\r\n Create a drop bpm effect (var bpm),\nduree = durée totale de la partie,\nnbr = nombre de division du drop,\nend = duree du drop en partant de la fin\npour retablir le tempo simplement drop(92)\n', 
    melody: '()\r\n Generate a melody based on Markov chain dict of melody ', chaos: '(chaosInt=1)\r\n Generate some random players ', 
    once: '(self)\r\n play a player once and stop it ', 
    start: '(self, startBeat=8)\r\n Start a player at a specific beat', 
    drummer: '(self, durloop=16, durPlyr=0.5)\r\n Transform the player into an automatic drummer '
};

function showDefinition(cm) {
  const cursor = cm.getCursor();
  const token = cm.getTokenAt(cursor);
  const word = token.string;

  // Remove any existing tooltips
  const existingTooltips = document.querySelectorAll('.CodeMirror-tooltip');
  existingTooltips.forEach(tooltip => removeTooltip(tooltip));

  if (definitions[word]) {
    const definition = definitions[word];
    const tooltip = makeTooltip(cm, cursor, definition);
    setTimeout(() => removeTooltip(tooltip), 10000); // Remove tooltip after 10 seconds
  }
}

function makeTooltip(cm, pos, content) {
  const tooltip = document.createElement('div');
  tooltip.className = 'CodeMirror-tooltip';
  tooltip.textContent = content;
  document.body.appendChild(tooltip);

  const left = cm.cursorCoords(pos, 'page').left;
  const rightEdge = left + tooltip.offsetWidth;
  const pageWidth = document.documentElement.clientWidth;

  if (rightEdge > pageWidth) {
    tooltip.style.left = `${pageWidth - tooltip.offsetWidth - 16}px`;
  } else {
    tooltip.style.left = `${left}px`;
  }

  tooltip.style.top = `${cm.cursorCoords(pos, 'page').bottom}px`;
  return tooltip;
}

function removeTooltip(tooltip) {
  if (tooltip && tooltip.parentNode) {
    tooltip.parentNode.removeChild(tooltip);
  }
}

export { showDefinition };